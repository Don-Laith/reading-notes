# Debugging
## ERROR HANDLING $ DEBUGGING
#### JavaScript can be hard to learn and everyone makes mistakes when writing it. This chapter will help you learn how to find the errors in your code. It will also teach you how to write scripts that deal with potential errors gracefully. When you are writing JavaScript, do not expect to write it perfectly the first time. Programming is like problem solving: you are given a puzzle and not only do you have to solve it, but you also need to create the instructions that allow the computer to solve it. too.
## ORDER OF EXECUTION
### To find the source of an error, it helps to know how scripts are processed. The order in which statements are executed can be complex; some tasks cannot complete until another statement or function has been run:
#### This script above creates a greeting message, then writes it to an alert box (see right-hand page). In order to create that greeting, two functions are used: greetUser() and getName() . You might think that the order of execution (the order in which statements are processed) would be as numbered: one through to four. However, it is a little more complicated. To complete step one, the interpreter needs the results of the functions in steps two and three (because the message contains values returned by those functions). The order of execution is more like this: 1, 2, 3, 2, 1, 4
## EXECUT.ION CONTEXTS
#### The JavaScript interpreter uses the concept of execution contexts. There is one global execution context; plus, each function creates a new new execution context. They correspond to variable scope.
## EXECUTION CONTEXT & HOISTING
#### This is because any variables and functions within each execution context are created before they are executed. The preparation phase is often described as taking all of the variables and functions and hoisting them to the top of the execution context. Or you can think of them as having been prepared. Each execution context also creates its own vari ab 1es object. This object contains details of all of the variables, functions, and parameters for that execution context.
## UNDERSTANDING SCOPE
### In the interpreter, each execution context has its own vari ables object. It holds the variables, functions, and parameters available within it. Each execution context can also access its parent's v ari ables object
#### If a variable is not found in the variables object for the current execution context, it can look in the variables object of the parent execution context. But it is worth knowing that looking further up the stack can affect performance, so ideally you create variables inside the functions that use them. If you look at the example on the left, the inner functions can access the outer functions and their variables. For example, the greetUser() function can access the time variable that was declared in the outer greeting() function. Each time a function is called, it gets its own execution context and var i ables object. Each time an outer function calls an inner function, the inner function can have a new variables object. But variables in the outer function remain the same. Note: you cannot access this variables object from your code; it is something the interpreter is creating and using behind the scenes. But understanding what goes on helps you understand scop.
## UNDERSTANDING ERRORS
##### If a JavaScript statement generates an error, then it throws an exception. At that point, the interpreter stops and looks for exception-handling code. If you are anticipating that something in your code may cause an error, you can use a set of statements to handle the error (you meet them on p480). This is important because if the error is not handled, the script will just stop processing and the user will not know why. So exception-handling code should inform users when there is a problem
### If an error happens in a function and the function does not have an exception handler, the interpreter goes to the line of code that called the function. In this case, the getName() function was called by greetUser(), so the interpreter looks for exceptionhandling code in the greetUser() function (2). If none is found, it continues to the next level, checking to see if there is code to handle the error in that execution context. It can continue until it reaches the global context, where it would have to it terminate the script, and create an Error object. So it is going through the stack looking for errorhandling code until it gets to the global context. If there is still no error handler, the script stops running and the Error object is created.