## Problem Domain, Objects, and the DOM
### getting multiple values out of a function
#### ANONYMOUS FUNCTIONS & FUNCTION EXPRESSIONS
##### Expressions produce a value. They can be used where values are expected. If a function is placed where a browser expects to see an expression, (e.g., as an argument to a function), then it gets treated as an expression.
### FUNCTION DECLARATION
#### A function declaration creates a function that you can call later in your code. It is the type of function you have seen so far in this book. In order to call the function later in your code, you must give it a name, so these are known as named functions. Below, a function called area() is declared, which can then be called using its name.
##### If you put a function where the interpreter would expect to see an expression, then it is treated as an expression, and it is known as a function expression. In function expressions, the name is usually omitted. A function with no name is called an anonymous function. Below, the function is stored in a variable called area. It can be called like any function created with a function declaration.
### IMMEDIATELY INVOKED FUNCTION EXPRESSIONS
#### This way of writing a function is used in several different situations. Often functions are used to ensure that the variable names do not conflict with each other (especially if the page uses more than one script). IMMEDIATELY INVOKED FUNCTION EXPRESSIONS (llFE) Pronounced "iffy," these functions are not given a name. Instead, they are executed once as the interpreter comes across them. Below, the variable called area will hold the value returned from the function (rather than storing the function itself so that it can be called later). var area =(ltunct i on() var wi dth = 3; var height = 2; return widt h * height; }DI); The final parentheses (shown on green) after the closing curly brace of the code block tell the interpreter to call the function immediately. The grouping operators (shown on pink) are parentheses there to ensure the intrepreter treats this as an expression. You may see the final parentheses in an llFE placed after the closing grouping operator but it is commonly considered better practice to place the final parentheses before the closing grouping operator, as shown in the code above. WHEN TO USE ANONYMOUS FUNCTIONS AND ll FES You will see many ways in which anonymous function expressions and llFEs are used throughout the book. They are used for code that only needs to run once within a task, rather than repeatedly being called by other parts of the script. For example: • As an argument when a function is called (to calculate a value for that function). • To assign the value of a property to an object. • In event handlers and listeners (see Chapter 6) to perform a task when an event occurs. • To prevent conflicts between two scripts that might use the same variable names (see p99). llFEs are commonly used as a wrapper around a set of code. Any variables declared within that anonymous function are effectively protected from variables in other scripts that might have the same name. This is due to a concept called scope, which you meet on the next page. It is also a very popular technique with jQuery. FUNCTIONS, METHODS & OBJECTS 8VARIABLE SCOPE The location where you declare a variable will affect where it can be used within your code. If you declare it within a function, it can only be used within that function. This is known as the variable's scope. LOCAL VARIABLES When a variable is created inside a function using the var keyword, it can only be used in that function. It is called a local variable or function-level variable. It is said to have local scope or function-level scope. It cannot be accessed outside of the function in which it was declared. Below, area is a local variable. The interpreter creates local variables when the function is run, and removes them as soon as the function has finished its task. This means that: • If the function runs twice, the variable can have different values each time. • Two different functions can use variables with the same name without any kind of naming conflict. GLOBAL VARIABLES If you create a variable outside of a function, then it can be used anywhere within the script. It is called a global variable and has global scope. In the example shown, wa11Size is a global variable. Global variables are stored in memory for as long as the web page is loaded into the web browser. This means they take up more memory than local
## Document Object
#### The Document Object Model (DOM) specifies how browsers should create a model of an HTML page and how JavaScript can access and update the contents of a web page while it is in the browser window.
##### The DOM is neither part of HTML, nor part of JavaScript; it is a separate set of rules. It is implemented by all major browser makers, and covers two primary areas: MAKING A MODEL OF THE HTM L PAGE When the browser loads a web page, it creates a model of the page in memory. The DOM specifies the way in which the browser should structure this model using a DOM tree. The DOM is called an object model because the model 
#### (the DOM tree) is made of objects. Each object represents a different part of the page loaded in the browser window. s DOCUMENT OBJECT MODEL ACCESSING AND CHANG ING THE HTML PAGE The DOM also defines methods and properties to access and update each object in this model, which in turn updates what the user sees in the browser.
## THE DOM TREE IS A MODEL OF A WEB PAGE
### As a browser loads a web page, it creates a model of that page. The model is called a DOM tree, and it is stored in the browsers' memory. It consists of four main types of nodes
#### THE DOCUMENT NODE Above, you can see the HTML code for a shopping list, and on the right hand page is its DOM tree. Every element, attribute, and piece of text in the HTML is represented by its own DOM node. At the top of the tree a document node is added; it represents the entire page (and also corresponds to the document object, which you first met on p36). When you access any element, attribute, or text node, you navigate to it via the document node. It is the starting point for all visits to the DOM tree
##### ATTRIBUTE NODES I 1i - attribute I text The opening tags of HTML elements can carry attributes and these are represented by attribute nodes in the DOM tree. Attribute nodes are not children of the element thar carries them; they are part of that element. Once you access an element, there are specific JavaScript methods and properties to read or change that element's attributes. For example, it is common to change the values of cl ass attributes to trigger new CSS rules that affect their presentation. ul 1i I text script - attribute attribute I l i - attribute I text TEXT NODES Once you have accessed an element node, you can then reach the text within that element. This is stored in its own text node. Text nodes cannot have children. If an element contains text and another child element, the child element is not a child of the text node but rather a child of the containing element. (See the <em> element on the first <l i > item.) This illustrates how the text node is always a new branch of the DOM tree, and no further branches come off of it.